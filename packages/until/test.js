import { jest } from '@jest/globals'
import { until, TimeoutError } from '.'

/**
 * @returns {[{value: number}, jest.MockedFunction<() => Promise<number>>]}
 */
function createAsyncCounter() {
  const count = { value: 0 }

  const counterSpy = jest.fn(async function counter() {
    await Promise.resolve()
    count.value = count.value + 1
    return count.value
  })

  return [count, counterSpy]
}

it('resolves returned promise when thunk returns an expected value', async () => {
  //
  // Given
  //

  const [count, counter] = createAsyncCounter()

  //
  // When
  //

  await until(counter, 3)

  //
  // Then
  //

  expect(counter).toBeCalledTimes(3)
  expect(count.value).toEqual(3)
})

it('re-evaluates thunk based on interval argument', async () => {
  //
  // Given
  //

  const [count, counter] = createAsyncCounter()
  const interval = 100
  const timeout = interval * 3

  //
  // When
  //

  await until(counter, 3, { interval, timeout })

  //
  // Then
  //

  expect(counter).toBeCalledTimes(3)
  expect(count.value).toEqual(3)
})

it('rejects promise if thunk does not return an expected value before the timeout argument', async () => {
  //
  // Given
  //

  expect.assertions(2)
  const [, counter] = createAsyncCounter()
  const interval = 100
  const timeout = interval / 2

  //
  // When
  //

  try {
    await until(counter, 3, { interval, timeout })
  } catch (error) {
    //
    // Then
    //

    if (error instanceof TimeoutError) {
      expect(error).toBeInstanceOf(TimeoutError)
      expect(error.message).toMatchInlineSnapshot(`"50 ms have passed"`)
    }
  }
})

it('throws an error in case timeout argument is less than 1', async () => {
  //
  // Given
  //

  expect.assertions(2)
  const [, counter] = createAsyncCounter()
  const timeout = 0

  //
  // When
  //

  try {
    await until(counter, 3, { timeout })
  } catch (error) {
    //
    // Then
    //

    if (error instanceof TypeError) {
      expect(error).toBeInstanceOf(TypeError)
      expect(error.message).toMatchInlineSnapshot(
        `"timeout needs to be greater than 0"`
      )
    }
  }
})

it('stops executing `thunk` once `timeout` is reached', async () => {
  //
  // Given
  //

  const [, counter] = createAsyncCounter()
  const timeout = 5
  const interval = 10

  //
  // When
  //

  try {
    await until(counter, 3, { interval, timeout })
    // eslint-disable-next-line no-empty
  } catch {}

  //
  // Then
  //

  expect(counter).toHaveBeenCalledTimes(1)
})

it('re-throws the error generated by the thunk', async () => {
  //
  // Given
  //

  const thunkErrorMessage = 'Thunk error message'
  async function thunk() {
    throw new Error(thunkErrorMessage)
    // eslint-disable-next-line no-unreachable
    return true
  }

  //
  // When
  //

  try {
    await until(thunk, true)
  } catch (error) {
    //
    // Then
    //

    if (error instanceof Error) {
      expect(error.message).toEqual(thunkErrorMessage)
    }
  }
})
