import { map } from '../map'
import { take } from '../take/index.js'
import { consume } from '../consume/index.js'
import { zip } from './index.js'

//
// Helpers
//

async function* generateNumbers() {
  const nextTick = Promise.resolve()
  let index = 0
  for (;;) {
    yield index
    index += 1
    await nextTick
  }
}

async function* generateNumbersModule3Equals0() {
  for await (const currentNumber of generateNumbers()) {
    if (currentNumber % 3 === 0) {
      yield currentNumber
    }
  }
}

async function* generateNumbersModule3Equals1() {
  for await (const currentNumber of generateNumbers()) {
    if (currentNumber % 3 === 1) {
      yield currentNumber
    }
  }
}

//
// Tests
//

it('returns an async generator which yields an array with generated values from all generators passed as input', async () => {
  const numbersModule3Equals0 = take(5, generateNumbersModule3Equals0())
  const numbersModule3Equals1 = take(5, generateNumbersModule3Equals1())

  const zipped = zip(numbersModule3Equals0, numbersModule3Equals1)
  const generatedValuesByZipped = await consume(zipped)

  expect(generatedValuesByZipped).toEqual([
    [0, 1],
    [3, 4],
    [6, 7],
    [9, 10],
    [12, 13],
  ])
})

it('sets returned generator as done as soon as any generator passed as input finishes', async () => {
  // Sets one of the generators as shorter than the others
  const numbersModule3Equals0 = take(3, generateNumbersModule3Equals0())
  const numbersModule3Equals1 = take(5, generateNumbersModule3Equals1())

  const zipped = zip(numbersModule3Equals0, numbersModule3Equals1)
  const generatedValuesByZipped = await consume(zipped)

  // The zipped generator should finish as soon as the shortest input finishes
  expect(generatedValuesByZipped).toEqual([
    [0, 1],
    [3, 4],
    [6, 7],
  ])
})

it('bubbles up error generated by generators passed as input', async () => {
  const evenNumbers = take(
    5,
    map(async (x) => x * 2, generateNumbers())
  )
  const oddNumbers = take(
    5,
    map(async (x) => {
      if (x >= 3) throw new Error('testing error propagation')
      return x * 2 + 1
    }, generateNumbers())
  )
  const zipped = zip(evenNumbers, oddNumbers)
  /** @type {number[][]} */
  const output = []
  async function thunk() {
    for await (const currentValue of zipped) {
      output.push(currentValue)
    }
  }

  await expect(thunk).rejects.toThrowError('testing error propagation')
  expect(output).toEqual([
    [0, 1],
    [2, 3],
    [4, 5],
  ])
})

it('works with a generator that generates no value', async () => {
  async function* generateOneValue() {
    yield 1
  }
  // eslint-disable-next-line require-yield
  async function* generateNoValue() {
    return
  }

  const zipped = zip(generateOneValue(), generateNoValue())
  const generatedValuesByZipped = await consume(zipped)
  expect(generatedValuesByZipped).toEqual([])
})
