import { map } from '../map'
import { take } from '../take/index.js'
import { consume } from '../consume/index.js'
import { zip } from './index.js'

//
// Helpers
//

async function* generateNumbers() {
  const nextTick = Promise.resolve()
  let index = 0
  for (;;) {
    yield index
    index += 1
    await nextTick
  }
}

async function* generateNumbersModule3Equals0() {
  for await (const currentNumber of generateNumbers()) {
    if (currentNumber % 3 === 0) {
      yield currentNumber
    }
  }
}

async function* generateNumbersModule3Equals1() {
  for await (const currentNumber of generateNumbers()) {
    if (currentNumber % 3 === 1) {
      yield currentNumber
    }
  }
}

async function* generateNumbersModule3Equals2() {
  for await (const currentNumber of generateNumbers()) {
    if (currentNumber % 3 === 2) {
      yield currentNumber
    }
  }
}

//
// Tests
//

it('returns an async generator which yields an array with generated values from all generators passed as input', async () => {
  const numbersModule3Equals0 = take(5, generateNumbersModule3Equals0())
  const numbersModule3Equals1 = take(5, generateNumbersModule3Equals1())
  const numbersModule3Equals2 = take(5, generateNumbersModule3Equals2())

  const zipped = zip(
    numbersModule3Equals0,
    numbersModule3Equals1,
    numbersModule3Equals2
  )
  const generatedValuesByZipped = await consume(zipped)

  expect(generatedValuesByZipped).toEqual([
    [0, 1, 2],
    [3, 4, 5],
    [6, 7, 8],
    [9, 10, 11],
    [12, 13, 14],
  ])
})

it('sets returned generator as done as soon as any generator passed as input finishes', async () => {
  // Sets one of the generators as shorter than the others
  const numbersModule3Equals0 = take(5, generateNumbersModule3Equals0())
  const numbersModule3Equals1 = take(5, generateNumbersModule3Equals1())
  const numbersModule3Equals2 = take(4, generateNumbersModule3Equals2())

  const zipped = zip(
    numbersModule3Equals0,
    numbersModule3Equals1,
    numbersModule3Equals2
  )
  const generatedValuesByZipped = await consume(zipped)

  // The zipped generator should finish as soon as the shortest input finishes
  expect(generatedValuesByZipped).toEqual([
    [0, 1, 2],
    [3, 4, 5],
    [6, 7, 8],
    [9, 10, 11],
  ])
})

it('accepts N inputs', async () => {
  const numbersMultipleOf2 = map(async (x) => (x + 1) * 2, generateNumbers())
  const numbersMultipleOf3 = map(async (x) => (x + 1) * 3, generateNumbers())
  const numbersMultipleOf5 = map(async (x) => (x + 1) * 5, generateNumbers())
  const numbersMultipleOf7 = map(async (x) => (x + 1) * 7, generateNumbers())

  const zipped = zip(
    numbersMultipleOf2,
    numbersMultipleOf3,
    numbersMultipleOf5,
    numbersMultipleOf7
  )
  const generatedValuesByZipped = await consume(take(2, zipped))

  expect(generatedValuesByZipped).toEqual([
    [2, 3, 5, 7],
    [4, 6, 10, 14],
  ])
})

it('bubbles up error generated by generators passed as input', async () => {
  const evenNumbers = take(
    5,
    map(async (x) => x * 2, generateNumbers())
  )
  const oddNumbers = take(
    5,
    map(async (x) => {
      if (x >= 3) throw new Error('testing error propagation')
      return x * 2 + 1
    }, generateNumbers())
  )
  const zipped = zip(evenNumbers, oddNumbers)
  /** @type {number[][]} */
  const output = []
  async function thunk() {
    for await (const currentValue of zipped) {
      output.push(currentValue)
    }
  }

  await expect(thunk).rejects.toThrowError('testing error propagation')
  expect(output).toEqual([
    [0, 1],
    [2, 3],
    [4, 5],
  ])
})
